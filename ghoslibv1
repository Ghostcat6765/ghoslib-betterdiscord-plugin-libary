/**
 * @name ghoslib
 * @author ghostcat.com
 * @version 1.0.0
 * @description Custom BetterDiscord plugin library for ghostcat plugins
 */

const ghosLibConfig = {
  info: {
    name: "ghoslib",
    authors: [{ name: "ghostcat.com", discord_id: "1394187937213845557" }],
    version: "1.0.0",
    description: "ghostcat's custom plugin library for BetterDiscord",
  },
};

module.exports = (() => {
  return class GhoslibPlugin {
    constructor() { this._config = ghosLibConfig; }
    getName() { return ghosLibConfig.info.name; }
    getAuthor() { return ghosLibConfig.info.authors[0].name; }
    getVersion() { return ghosLibConfig.info.version; }
    getDescription() { return ghosLibConfig.info.description; }
    load() { console.log("%c[ghoslib] Library loaded", "color: #10b981; font-weight: bold;"); }
    start() {
      if (!window.ghoslib) {
        window.ghoslib = {
          version: "1.0.0",
          author: "ghostcat.com",
          Logger: {
            info: (msg, ...args) => console.log(`%c[ghoslib] â„¹ï¸ ${msg}`, "color: #667eea; font-weight: bold;", ...args),
            warn: (msg, ...args) => console.warn(`%c[ghoslib] âš ï¸ ${msg}`, "color: #f59e0b; font-weight: bold;", ...args),
            error: (msg, ...args) => console.error(`%c[ghoslib] âŒ ${msg}`, "color: #ef4444; font-weight: bold;", ...args),
            success: (msg, ...args) => console.log(`%c[ghoslib] âœ… ${msg}`, "color: #10b981; font-weight: bold;", ...args),
            debug: (msg, ...args) => console.debug(`%c[ghoslib] ðŸ› ${msg}`, "color: #8b5cf6; font-weight: bold;", ...args),
          },
          DOM: {
            query: (selector) => document.querySelector(selector),
            queryAll: (selector) => Array.from(document.querySelectorAll(selector)),
            createElement: (tag, options = {}) => {
              const el = document.createElement(tag);
              if (options.text) el.textContent = options.text;
              if (options.html) el.innerHTML = options.html;
              if (options.classes && Array.isArray(options.classes)) el.classList.add(...options.classes);
              if (options.styles && typeof options.styles === "object") Object.assign(el.style, options.styles);
              return el;
            },
            on: (el, event, handler) => {
              if (!el) return () => {};
              el.addEventListener(event, handler);
              return () => el.removeEventListener(event, handler);
            },
            waitFor: (selector, timeout = 5000) => new Promise((resolve) => {
              const el = document.querySelector(selector);
              if (el) return resolve(el);
              const observer = new MutationObserver(() => {
                const el = document.querySelector(selector);
                if (el) { observer.disconnect(); resolve(el); }
              });
              observer.observe(document.body, { childList: true, subtree: true });
              setTimeout(() => { observer.disconnect(); resolve(null); }, timeout);
            }),
          },
          Storage: {
            get: (key, defaultValue = null) => {
              try {
                const item = localStorage.getItem(`ghoslib_${key}`);
                return item ? JSON.parse(item) : defaultValue;
              } catch (e) {
                window.ghoslib.Logger.error(`Storage.get failed for key: ${key}`, e);
                return defaultValue;
              }
            },
            set: (key, value) => {
              try {
                localStorage.setItem(`ghoslib_${key}`, JSON.stringify(value));
                return true;
              } catch (e) {
                window.ghoslib.Logger.error(`Storage.set failed for key: ${key}`, e);
                return false;
              }
            },
            remove: (key) => {
              try {
                localStorage.removeItem(`ghoslib_${key}`);
                return true;
              } catch (e) {
                window.ghoslib.Logger.error(`Storage.remove failed for key: ${key}`, e);
                return false;
              }
            },
            clear: () => {
              try {
                const keys = Object.keys(localStorage).filter((k) => k.startsWith("ghoslib_"));
                keys.forEach((k) => localStorage.removeItem(k));
                return true;
              } catch (e) {
                window.ghoslib.Logger.error("Storage.clear failed", e);
                return false;
              }
            },
          },
          Audio: {
            getContext: () => {
              try {
                return new (window.AudioContext || window.webkitAudioContext)();
              } catch (e) {
                window.ghoslib.Logger.error("Failed to create AudioContext", e);
                return null;
              }
            },
            getAllAudioElements: () => Array.from(document.querySelectorAll("audio")),
            hasMediaStream: (audioEl) => audioEl && audioEl.srcObject instanceof MediaStream,
            processStream: (ctx, stream, processorFn) => {
              try {
                const source = ctx.createMediaStreamSource(stream);
                const destination = ctx.createMediaStreamDestination();
                processorFn(source, destination, ctx);
                return destination.stream;
              } catch (e) {
                window.ghoslib.Logger.error("Audio processing failed", e);
                return null;
              }
            },
          },
          Utils: {
            debounce: (fn, delay) => {
              let timeoutId;
              return function (...args) {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(() => fn.apply(this, args), delay);
              };
            },
            throttle: (fn, limit) => {
              let inThrottle;
              return function (...args) {
                if (!inThrottle) {
                  fn.apply(this, args);
                  inThrottle = true;
                  setTimeout(() => (inThrottle = false), limit);
                }
              };
            },
            clone: (obj) => JSON.parse(JSON.stringify(obj)),
            merge: (target, source) => {
              const output = Object.assign({}, target);
              for (const key in source) {
                if (typeof source[key] === "object" && source[key] !== null && !Array.isArray(source[key])) {
                  output[key] = window.ghoslib.Utils.merge(output[key] || {}, source[key]);
                } else {
                  output[key] = source[key];
                }
              }
              return output;
            },
            generateId: () => Math.random().toString(36).substring(2, 11),
            sleep: (ms) => new Promise((resolve) => setTimeout(resolve, ms)),
            parseQuery: (str) => {
              const params = new URLSearchParams(str);
              const result = {};
              for (const [key, value] of params) result[key] = value;
              return result;
            },
          },
          UI: {
            toast: (message, type = "info", duration = 3000) => {
              const toast = window.ghoslib.DOM.createElement("div", {
                text: message,
                classes: ["ghoslib-toast", `ghoslib-toast-${type}`],
                styles: {
                  position: "fixed", bottom: "20px", right: "20px",
                  background: type === "success" ? "#10b981" : type === "error" ? "#ef4444" : type === "warn" ? "#f59e0b" : "#667eea",
                  color: "white", padding: "12px 20px", borderRadius: "8px", fontSize: "14px", fontWeight: "500",
                  zIndex: "9999", boxShadow: "0 4px 12px rgba(0, 0, 0, 0.15)",
                },
              });
              document.body.appendChild(toast);
              setTimeout(() => toast.remove(), duration);
            },
            modal: (title, content, callbacks = {}) => {
              const { onConfirm, onCancel } = callbacks;
              const modal = window.ghoslib.DOM.createElement("div", {
                classes: ["ghoslib-modal"],
                styles: { position: "fixed", top: "0", left: "0", width: "100%", height: "100%", background: "rgba(0, 0, 0, 0.6)", display: "flex", justifyContent: "center", alignItems: "center", zIndex: "10000" },
              });
              const box = window.ghoslib.DOM.createElement("div", {
                classes: ["ghoslib-modal-box"],
                styles: { background: "white", padding: "30px", borderRadius: "12px", maxWidth: "400px", boxShadow: "0 20px 60px rgba(0, 0, 0, 0.3)" },
              });
              const titleEl = window.ghoslib.DOM.createElement("h2", { text: title, styles: { marginBottom: "15px", color: "#333", fontSize: "20px" } });
              const contentEl = window.ghoslib.DOM.createElement("p", { text: content, styles: { marginBottom: "20px", color: "#666", lineHeight: "1.5", fontSize: "14px" } });
              const btnGroup = window.ghoslib.DOM.createElement("div", { styles: { display: "flex", gap: "10px" } });
              const confirmBtn = window.ghoslib.DOM.createElement("button", {
                text: "Confirm",
                styles: { flex: "1", padding: "10px", background: "#667eea", color: "white", border: "none", borderRadius: "6px", cursor: "pointer", fontWeight: "600", fontSize: "14px" },
              });
              confirmBtn.onclick = () => { modal.remove(); if (onConfirm) onConfirm(); };
              const cancelBtn = window.ghoslib.DOM.createElement("button", {
                text: "Cancel",
                styles: { flex: "1", padding: "10px", background: "#f0f0f0", color: "#333", border: "none", borderRadius: "6px", cursor: "pointer", fontWeight: "600", fontSize: "14px" },
              });
              cancelBtn.onclick = () => { modal.remove(); if (onCancel) onCancel(); };
              btnGroup.appendChild(confirmBtn);
              btnGroup.appendChild(cancelBtn);
              box.appendChild(titleEl);
              box.appendChild(contentEl);
              box.appendChild(btnGroup);
              modal.appendChild(box);
              document.body.appendChild(modal);
            },
          },
          Observer: {
            onDOM: (callback, options = {}) => {
              const config = { childList: true, subtree: true, attributes: false, characterData: false, ...options };
              const observer = new MutationObserver(callback);
              observer.observe(document.body, config);
              return observer;
            },
          },
          Hooks: {
            _hooks: {},
            register: (name, callback) => {
              if (!window.ghoslib.Hooks._hooks[name]) window.ghoslib.Hooks._hooks[name] = [];
              window.ghoslib.Hooks._hooks[name].push(callback);
              return () => { window.ghoslib.Hooks._hooks[name] = window.ghoslib.Hooks._hooks[name].filter((cb) => cb !== callback); };
            },
            fire: (name, data) => {
              if (window.ghoslib.Hooks._hooks[name]) {
                window.ghoslib.Hooks._hooks[name].forEach((callback) => {
                  try { callback(data); } catch (e) {
                    window.ghoslib.Logger.error(`Hook ${name} error:`, e);
                  }
                });
              }
            },
          },
          Settings: {
            _settings: {},
            register: (pluginName, defaultConfig) => {
              window.ghoslib.Settings._settings[pluginName] = { ...defaultConfig };
              return {
                get: (key, defaultValue = null) => window.ghoslib.Settings._settings[pluginName][key] ?? defaultValue,
                set: (key, value) => {
                  window.ghoslib.Settings._settings[pluginName][key] = value;
                  window.ghoslib.Storage.set(`settings_${pluginName}_${key}`, value);
                },
                getAll: () => ({ ...window.ghoslib.Settings._settings[pluginName] }),
                load: () => {
                  const stored = window.ghoslib.Storage.get(`settings_${pluginName}_all`, null);
                  if (stored) window.ghoslib.Settings._settings[pluginName] = stored;
                },
                save: () => {
                  window.ghoslib.Storage.set(`settings_${pluginName}_all`, window.ghoslib.Settings._settings[pluginName]);
                },
              };
            },
          },
          EventEmitter: class {
            constructor() { this._events = {}; }
            on(event, listener) {
              if (!this._events[event]) this._events[event] = [];
              this._events[event].push(listener);
              return () => this.off(event, listener);
            }
            off(event, listener) {
              if (this._events[event]) this._events[event] = this._events[event].filter((l) => l !== listener);
            }
            emit(event, ...args) {
              if (this._events[event]) {
                this._events[event].forEach((listener) => {
                  try { listener(...args); } catch (e) {
                    window.ghoslib.Logger.error(`Event ${event} error:`, e);
                  }
                });
              }
            }
            once(event, listener) {
              const wrapped = (...args) => {
                listener(...args);
                this.off(event, wrapped);
              };
              return this.on(event, wrapped);
            }
          },
          State: {
            create: (initialState = {}) => {
              let state = { ...initialState };
              const listeners = [];
              return {
                get: () => ({ ...state }),
                set: (updates) => {
                  const prev = { ...state };
                  state = { ...state, ...updates };
                  listeners.forEach((listener) => listener(state, prev));
                },
                subscribe: (listener) => {
                  listeners.push(listener);
                  return () => listeners.splice(listeners.indexOf(listener), 1);
                },
                reset: (values) => { state = { ...initialState, ...values }; },
              };
            },
          },
          Cache: {
            _cache: {},
            set: (key, value, ttl = null) => {
              window.ghoslib.Cache._cache[key] = { value, expires: ttl ? Date.now() + ttl : null };
            },
            get: (key) => {
              const item = window.ghoslib.Cache._cache[key];
              if (!item) return null;
              if (item.expires && item.expires < Date.now()) {
                delete window.ghoslib.Cache._cache[key];
                return null;
              }
              return item.value;
            },
            remove: (key) => { delete window.ghoslib.Cache._cache[key]; },
            clear: () => { window.ghoslib.Cache._cache = {}; },
          },
        };
        window.ghoslib.Logger.success("ghoslib initialized globally");
      }
    }
    stop() { console.log("%c[ghoslib] Plugin stopped", "color: #f59e0b; font-weight: bold;"); }
  };
})();
